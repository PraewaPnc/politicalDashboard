// ===============================
// Constants
// ===============================
const GRAPHQL_ENDPOINT = "https://politigraph.wevis.info/graphql";

// Vote Events cache
const CACHE_KEY = "voteDataCache_v1";
const STAGING_KEY = "voteDataStaging_v1";

// Organizations cache
const ORG_CACHE_KEY = "orgCache_v1";
const ORG_STAGING_KEY = "orgStaging_v1";

const CACHE_TTL = 24 * 60 * 60 * 1000; // 24h

// ===============================
// GraphQL Queries
// ===============================
const QUERY_VOTE_EVENTS = `
  query VoteEvents {
    voteEvents {
      start_date
      title
      description
      result
      agree_count
      disagree_count
      abstain_count
      novote_count
      votes {
        id
        voter_name
        voter_party
        option_en
      }
    }
  }
`;

const QUERY_ORGANIZATIONS = `
  query Organizations {
    organizations {
      id
      name
      color
    }
  }
`;

// ===============================
// Utility Functions
// ===============================
const isAbsent = (option) => {
  if (!option) return false;
  const t = String(option).toLowerCase();
  return t.includes("absent") || t.includes("‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà");
};

const safeJSONParse = (str) => {
  try {
    return JSON.parse(str);
  } catch {
    return null;
  }
};

/**
 * NEW: Fetches the cleaned party map generated by the Python script.
 * @returns {Promise<Object<string, string>>} A map of {vote_id: cleaned_party_name}.
 */
async function fetchCleanedPartyMap() {
  try {
    // IMPORTANT: Ensure this path is correct for where you placed the output file
    const res = await fetch('./cleaned_party_map.json'); 
    if (!res.ok) throw new Error("Failed to load cleaned party map.");
    return await res.json();
  } catch (err) {
    console.error("Failed to load party cleaning map (Defaulting to original parties):", err);
    return {};
  }
}


// ===============================
// Cache & Staging Helpers
// ===============================
function readStorage(key, checkTTL = false) {
  const raw = localStorage.getItem(key);
  if (!raw) return null;
  const obj = safeJSONParse(raw);
  if (!obj) return null;

  if (checkTTL && (!obj.timestamp || Date.now() - obj.timestamp > CACHE_TTL)) {
    localStorage.removeItem(key);
    return null;
  }

  return checkTTL ? obj.data : obj;
}

function writeStorage(key, data, includeTimestamp = false) {
  try {
    const payload = includeTimestamp ? { timestamp: Date.now(), data } : data;
    localStorage.setItem(key, JSON.stringify(payload));
  } catch (e) {
    console.warn(`Storage write failed (${key})`, e);
  }
}

// ===============================
// GraphQL Fetcher
// ===============================
async function fetchGraphQL(query) {
  try {
    const res = await fetch(GRAPHQL_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query }),
    });
    const json = await res.json();
    return json.data || {};
  } catch (err) {
    console.error("GraphQL fetch error:", err);
    return {};
  }
}

// ===============================
// Vote Event Transformation (Updated for Merge)
// ===============================
function transformVoteEvents(rawEvents, cleanedPartyMap = {}) { // <-- Added cleanedPartyMap
  if (!Array.isArray(rawEvents)) return [];

  return rawEvents.map((ev) => {
    const start_date = ev.start_date?.slice(0, 10) || null;
    const dt = start_date ? new Date(start_date) : null;
    const year = dt?.getUTCFullYear() || null;
    const month = dt ? dt.getUTCMonth() + 1 : null;

    const votes = Array.isArray(ev.votes)
      ? ev.votes.map((v) => {
          // --- JOIN LOGIC START ---
          const voteId = v.id;
          const original_party = v.voter_party ?? "‡∏≠‡∏∑‡πà‡∏ô‡πÜ";
          
          // Look up the cleaned party name using the individual vote ID
          const cleaned_party = cleanedPartyMap[voteId] || original_party;

          // --- JOIN LOGIC END ---
          
          return {
            id: voteId, // Keep the vote ID
            voter_name: v.voter_name ?? "__UNKNOWN__",
            voter_party: cleaned_party ?? "‡∏≠‡∏∑‡πà‡∏ô‡πÜ", // <-- Use the cleaned party name
            option_en: v.option_en ?? "",
          }
        })
      : [];

    const unique = new Map(votes.map((v) => [v.voter_name, v]));
    const totalVoters = unique.size;
    let presentCount = 0;
    // These objects now use the CLEANED party names for aggregation
    const partyBreakdown = {}; 
    const totalByParty = {};

    for (const { voter_party, option_en } of unique.values()) {
      totalByParty[voter_party] = (totalByParty[voter_party] || 0) + 1;
      if (!isAbsent(option_en)) {
        presentCount++;
        partyBreakdown[voter_party] = (partyBreakdown[voter_party] || 0) + 1;
      }
    }

    const presentPercent = totalVoters
      ? +(presentCount / totalVoters * 100).toFixed(1)
      : 0;

    const agree = +ev.agree_count || 0;
    const disagree = +ev.disagree_count || 0;
    const abstain = +ev.abstain_count || 0;
    const novote = +ev.novote_count || 0;
    const totalVotes = agree + disagree + abstain + novote || 0;

    const categoryPercentages = totalVotes
      ? {
          agree: +(agree / totalVotes * 100).toFixed(1),
          disagree: +(disagree / totalVotes * 100).toFixed(1),
          abstain: +(abstain / totalVotes * 100).toFixed(1),
          novote: +(novote / totalVotes * 100).toFixed(1),
        }
      : { agree: 0, disagree: 0, abstain: 0, novote: 0 };

    return {
      date: dt,
      dateStr: start_date,
      year,
      month,
      title: ev.title ?? "Untitled",
      description: ev.description ?? "No description",
      result: ev.result ?? null,
      agree_count: agree,
      disagree_count: disagree,
      abstain_count: abstain,
      novote_count: novote,
      totalVotes,
      categoryPercentages,
      votes,
      totalVoters,
      presentCount,
      presentPercent,
      partyBreakdown,
      totalByParty,
      result: ev.result ?? null,
    };
  }).sort((a, b) =>
    (a.dateStr || "").localeCompare(b.dateStr || "") ||
    a.title.localeCompare(b.title)
  );
}

// ===============================
// Public: Fetch Vote Data (Updated for Map Loading)
// ===============================
export async function fetchVoteData() {
  // 1Ô∏è‚É£ Try cache first
  const cached = readStorage(CACHE_KEY, true);
  if (cached) {
    console.log("‚úÖ Loaded vote data from cache");
    return cached;
  }

  // 2Ô∏è‚É£ Fetch live data
  console.log("üåê Fetching vote data from GraphQL...");
  const { voteEvents = [] } = await fetchGraphQL(QUERY_VOTE_EVENTS);
  
  // 3Ô∏è‚É£ NEW: Fetch the cleaned party map
  console.log("Fetching cleaned party name map...");
  const cleanedPartyMap = await fetchCleanedPartyMap();

  // 4Ô∏è‚É£ Fallback to staging if fetch fails
  if (!voteEvents.length) {
    console.warn("‚ö†Ô∏è Using staging data fallback...");
    const staging = readStorage(STAGING_KEY);
    if (staging) return staging;
    throw new Error("No staging data available and API fetch failed.");
  }

  // 5Ô∏è‚É£ Transform + Save
  const records = transformVoteEvents(voteEvents, cleanedPartyMap); // <-- Pass the map here
  writeStorage(CACHE_KEY, records, true);
  writeStorage(STAGING_KEY, records);
  console.log("‚úÖ Data fetched and saved to cache + staging");

  return records;
}

// ===============================
// Public: Force Refresh
// ===============================
export async function forceRefreshVoteData() {
  console.log("üîÑ Forcing refresh from GraphQL...");
  const { voteEvents = [] } = await fetchGraphQL(QUERY_VOTE_EVENTS);
  if (!voteEvents.length) {
    console.warn("‚ùå GraphQL returned no data, keeping old staging.");
    return null;
  }
  
  // NEW: Fetch the map for a force refresh as well
  const cleanedPartyMap = await fetchCleanedPartyMap();

  const records = transformVoteEvents(voteEvents, cleanedPartyMap);
  writeStorage(CACHE_KEY, records, true);
  writeStorage(STAGING_KEY, records);
  console.log("‚úÖ Data refreshed and stored to cache + staging");

  return records;
}

// ===============================
// Hierarchy Builder for Absence
// ===============================
export function buildAbsenceHierarchy(records) {
  const titlesPerYear = new Map();
  const nested = {};

  for (const r of records) {
    if (!r.year) continue;
    titlesPerYear.set(r.year, (titlesPerYear.get(r.year) || 0) + 1);

    for (const v of r.votes || []) {
      const party = v.voter_party || "‡∏≠‡∏∑‡πà‡∏ô‡πÜ"; // This will be the CLEANED party name
      const voter = v.voter_name || "__UNKNOWN__";
      const absent = isAbsent(v.option_en) ? 1 : 0;

      nested[r.year] ??= {};
      nested[r.year][party] ??= {};
      nested[r.year][party][voter] = (nested[r.year][party][voter] || 0) + absent;
    }
  }

  const root = { name: "All Years", children: [] };

  for (const [year, parties] of Object.entries(nested).sort((a, b) => +b[0] - +a[0])) {
    const totalTitles = titlesPerYear.get(+year) || 1;
    const yearNode = { name: year, totalTitles, children: [] };

    for (const [party, voters] of Object.entries(parties)) {
      const votersArr = Object.entries(voters)
        .filter(([_, count]) => count > 0)
        .map(([voter, count]) => ({ name: voter, value: count }));

      if (votersArr.length) {
        const totalAbsent = votersArr.reduce((sum, v) => sum + v.value, 0);
        yearNode.children.push({ name: party, totalAbsent, children: votersArr });
      }
    }

    if (yearNode.children.length) root.children.push(yearNode);
  }

  return root;
}

// ===============================
// Public: Organizations with Cache
// ===============================
export async function fetchOrganizations() {
  // 1Ô∏è‚É£ Try cache first (with TTL)
  const cached = readStorage(ORG_CACHE_KEY, true);
  if (cached) {
    console.log("‚úÖ Loaded organizations from cache");
    return cached;
  }

  // 2Ô∏è‚É£ Fetch live data
  console.log("üåê Fetching organizations from GraphQL...");
  const { organizations = [] } = await fetchGraphQL(QUERY_ORGANIZATIONS);

  // 3Ô∏è‚É£ Fallback to staging if fetch fails
  if (!organizations.length) {
    console.warn("‚ö†Ô∏è Using staging organizations fallback...");
    const staging = readStorage(ORG_STAGING_KEY);
    if (staging) return staging;
    throw new Error("No org staging data available and API fetch failed.");
  }

  // 4Ô∏è‚É£ Save both cache + staging
  writeStorage(ORG_CACHE_KEY, organizations, true);
  writeStorage(ORG_STAGING_KEY, organizations);
  console.log("‚úÖ Organizations fetched and saved to cache + staging");

  return organizations;
}

// ===============================
// Public: Get Party Colors
// ===============================
export async function getPartyColors() {
  const organizations = await fetchOrganizations();

  const colors = Object.fromEntries(
    organizations
      .filter((org) => org.name && org.color)
      .map((org) => {
        let name = org.name.trim();

        // ‚úÖ add prefix ‚Äú‡∏û‡∏£‡∏£‡∏Ñ‚Äù if not already there
        if (!name.startsWith("‡∏û‡∏£‡∏£‡∏Ñ") && name !== "‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ß‡∏∏‡∏í‡∏¥‡∏™‡∏†‡∏≤" && name !== "‡∏≠‡∏∑‡πà‡∏ô‡πÜ") {
          name = "‡∏û‡∏£‡∏£‡∏Ñ" + name;
        }

        return [name, org.color];
      })
  );

  colors["Other"] = "#BBBBBB";
  colors["‡∏≠‡∏∑‡πà‡∏ô‡πÜ"] = "#BBBBBB"; // ‚úÖ also cover Thai ‚Äú‡∏≠‡∏∑‡πà‡∏ô‡πÜ‚Äù
  return colors;
}